# SimpleMicroDiff (SMDIFF)
A VCDIFF inspired Encoding Scheme for file differencing.

## 1. Executive Summary

**SMDIFF** is a binary delta encoding format designed for efficient representation and transmission of differences between two related data sets (source and target). It is inspired by and translatable between the VCDIFF (RFC 3284) format, aiming to provide a simpler and potentially more compact alternative.


## 2. Conventions

The basic data unit is a byte.  For portability, SMDIFF shall limit a
byte to its lower eight bits even on machines with larger bytes. The
bits in a byte are ordered from right to left so that the least
significant bit (LSB) has value 1, and the most significant bit
(MSB), has value 128.

For purposes of exposition in this document, we adopt the convention
that the LSB is numbered 0, and the MSB is numbered 7.  Bit numbers
never appear in the encoded format itself.

SMDIFF employs two variable-length integer encoding types, derived from the varint format used in Protocol Buffers. This scheme efficiently represents signed integers in a compact manner, especially for smaller values. There is a u-varint (normal protocol buffer spec), and an i-varint.

The i-varint format utilizes the concept of zig-zag encoding to map signed integers to unsigned values. This transformation allows negative numbers to be encoded efficiently alongside positive ones.

The resulting unsigned value is then encoded using the u-varint variable-length scheme where the most significant bit (MSB) of each byte acts as a continuation bit. If the MSB is set, it indicates that another byte follows; otherwise, it's the final byte of the encoded integer. The remaining seven bits of each byte store the integer's binary representation.

This approach offers two key advantages:

Portability: The encoding is compatible across systems using 8-bit bytes.

Compactness: Smaller integer values, both positive and negative, are encoded using fewer bytes.

Example:
Let's consider the signed integer -123456789. Using zig-zag encoding, it is mapped to the unsigned integer 246913577 and then encoded per a normal u-varint. The u and i-varint encoding of this number is as follows:
```
i-varint = -123456789 && u-varint = 246913577 ==
+-------------------------------------------+
| 10101001 | 10110100 | 11011110 | 01110101 |
+-------------------------------------------+
  0xA9       0xB4       0xDE       0x75
```

Henceforth, the terms "byte" and "u-varint" and "i-varint" will refer to a byte, an unsigned integer, and a signed integer as described.

## 3. Delta Operations
In SMDIFF, we do not divide up the source or target in to windows. Instead, any Copy operations encountered considers the entirety of the Dictionary (initial or source) file, and the entirety of the Target (output) file generated so far.

There are three types of delta operation in SMDIFF:

*   **ADD:** This operation has two arguments, a size x and a sequence of x bytes to be copied.
*   **RUN:** This operation has two arguments, a size x and a byte b, that will be repeated x times.
*   **COPY:** This operation has two arguments, a size x and an address p from either the Dictionary or the Target.

The maximum size for ADD and COPY operations is limited to `u16::MAX` (65,535 bytes). RUN operations are limited to a maximum length of 62. To encode longer lengths, multiple operation should be used.

Below are example source and target *files* and the delta operation that encode the target file in terms of the source file.

  ```
        a b c d e f g h i j k l m n o p
        a b c d w x y z e f g h e f g h e f g h e f g h z z z z

        COPY_D  4, 0
        ADD     4, w x y z
        COPY_D  4, 4
        COPY_O  4, 8
        COPY_O  4, 8
        COPY_O  4, 8
        RUN     4, z
```
COPY_D is used to indicate a copy from the source or dictionary file. The first operation copies "abcd" from the dictionary and places it in the output. COPY_O is used to copy from earlier within the output. Unfortunately the original RFC3284 does not illustrate this well as we could have used COPY_D(4,4) and repeated that operation. However, this example does illustrate our lack of periodic sequence encoding in SMDIFF.

To reconstruct the target window, one simply processes one delta operation at a time and copies the data, either from the dictionary file or the target file being reconstructed, based on the type of the operation and the associated address, if any.

## 4. Delta File Organization

An SMDIFF delta file has two different flavors. Regardless of the format, the output generated by each section of operations MUST NOT exceed `u24::MAX` (16,777,215 bytes).

### 4.1 Micro Format
```
File Header
    Header - byte
Operations(Micro) - array of operations
```

### 4.2 Window Format
```
File Header
    Header - byte
Window Header
    Number of operations - u-varint
    Number of Add Bytes  - u-varint
    Output size          - u-varint*
Operations(Window) - array of operations
Add Bytes - array of bytes
```
*Note: See Layout Details for how to interpret this value.

### 4.3 Layout Details

#### 4.3.1 File Header
The file header provides essential information about the encoding format and compression algorithm used:

```
     7 6 5 4 3 2 1 0
    +-+-+-+-+-+-+-+-+
    |         | |   |
    +-+-+-+-+-+-+-+-+
         ^     ^  ^ Compression Algo (u2)
         |     +--- Format (bool)
         +------ Operations Count (MicroFormat only, u5)
```

| Bit(s) | Field               | Description        |
| ----- | ------------------- | -------------------- |
| 0-1   | Compression Algo    | 0 = None, 1 = Low Overhead, 2 = Larger inputs, 3 = Unused                                            |
| 2     | Format              | 0 = MicroFormat, 1 = WindowFormat                                                                    |
| 3-7   | **MicroFormat:** Operations Count<br>**WindowFormat:** Unused | Number of operations in the file (MicroFormat only) |

**Note:** The Compression Algo field is currently unspecified and reserved for future use.

#### 4.3.2 Window Header

The WindowHeader provides information about the number of operations, the total size of ADD data, and the expected output size of the window:

| Element           | Type   | Description             |
| ----------------- | ------ | ----------------------- |
| Number of operations | u-varint | Number of delta operations in the window                                                                 |
| Number of Add Bytes | u-varint | Total number of bytes in the ADD operations that follow the encoded operations                           |
| Output size        | u-varint | Difference-encoded representation of the actual output size. The true output size is this value plus the Number of Add Bytes. |

**Note:** The output size of each section (MicroFormat or WindowFormat) MUST NOT exceed `u24::MAX` (16,777,215 bytes).

### 4.4 Delta Operation Layout

The basic layout for operations in either format is:
```
Operation
    OpByte - Byte
    [Size Indicator]
    [Additional Field] (Always present in Micro Format)
```

#### 4.4.1 Operation Byte (OpByte)

Each delta operation is represented by an OpByte followed by optional size indicators and additional fields.

```
     7 6 5 4 3 2 1 0
    +-+-+-+-+-+-+-+-+
    |           |   |
    +-+-+-+-+-+-+-+-+
           ^      ^ Operation Type (u2)
           |
           +------ Size Value (u6)
```

| Bit(s) | Description                                                                 |
| ------ | --------------------------------------------------------------------------- |
| 0-1    | **Operation Type**<br>0 = CopyDict<br>1 = CopyOutput<br>2 = Add<br>3 = Run |
| 2-7    | **Size Value** See next section on interpretation of value |

#### 4.4.2 Size Indicator

If the size is *not* in the range of 1..=62 then there will be additional data to read.

This implies that we cannot allow 0 length operations, which seems logical. A Size Indicator is never present on Run Operations.

| Condition           | Type    | Description                     |
| ------------------- | ----    | ------------------------------- |
| If Size Value == 63 | u8      | Read u8 and add 62 to its value |
| If Size Value == 0  | u16_le  | Read u16, this is the size      |
| If Size Value 1..=62| null    | Size Value is the Size, no Size Indicator|

#### 4.4.3 Additional Field

Additional Field depend on the operation type and the section format:

##### 4.4.3.1. Micro Format

```
Additional Field
    [Copy Address] - i-varint
    [Add Bytes]    - array of bytes
    [Run Byte]     - byte
```
In micro format we will have exactly one of the fields and it must match the Operation Type listed in the OpByte.

| Field        | Condition            | Type        | Description        |
| ------------ | -------------------- | ----------- | ------------------ |
| Copy Address | If operation is Copy | i-varint     | CopyD = i-var-int from the last CopyDict address seen<br>CopyO = i-var-int from the last CopyOutput address seen |
| Add Bytes    | If operation is Add  | byte[]      | Bytes to be added, with length as specified    |
| Run Bytes    | If operation is Run  | byte        | A single byte representing the repeated byte   |

##### 4.4.3.2. Window Format
```
Additional Field
    [Copy Address] - i-varint
    [Run Byte]     - byte
```
In window format we will have exactly one of the fields and it must match the Operation Type listed in the OpByte. Add bytes are never placed in the Additional Field. They are concatenated together and placed after all the operations.


| Field        | Condition            | Type        | Description                                                                                |
| ------------ | -------------------- | ----------- | ------------------------------------------------------------------------------------------ |
| Copy Address | If operation is Copy | i-varint     | CopyD = i-var-int from the last CopyDict address seen<br>CopyO = i-var-int from the last CopyOutput address seen |
| Run Byte     | If operation is Run  | byte        | Single byte representing the repeated byte                                                  |

## 5. Delta Operation Encoding
A difference in this spec from the VCDIFF spec is that we do not have two operations per byte (complicated instruction table), and we also do not have any special 'modes' for address encoding.

While this may make the resulting delta file larger, it greatly simplifies the spec.

### 5.1 Address Encoding
We simply use an i-varint to denote the *difference* from the last copy address used from that source. Each new section we set `last_dict_addr` and `last_out_addr` to zero. Then each time we read a Copy from either the dict or the out, we simply use the signed integer value and add it to the appropriate `last_addr`. This is the absolute offset from the start of which ever file we need to start copying from. This absolute value is then set to the appropriate `last_addr` variable for reading on the next Copy operation encountered.



## 6. Performance
TODO
Using the table from the original RFC. I have added something similar using the exact same data.
- Target Against Target
- Target Against Source at same starting (not how our Encoder works)
- Target Against Source & Target (Probably not fair to compare to SMDIFF)
- Target Against Source & Target with windowing algo (probably most comparable for SMDIFF)

```
                gcc-2.95.1     gcc-2.95.2     gcc-2.95.3
---------------------------------------------------------
1. raw size      55,746,560     55,797,760     55,787,520
2. compress         -           19,939,390     19,939,453
3. gzip             -           12,973,443     12,998,097
4. Vcdiff           -           15,358,786     15,371,737
5. Vcdiff-d         -              100,971     26,383,849
6. Vcdiff-dc        -               97,246     14,461,203
7. Vcdiff-dcw       -              256,445      1,248,543
8. Smdiff           -                  TBD      TBD
9. Smdiff-d         -              100,971     26,383,849
10.Smdiff-dc        -               97,246     14,461,203
11.Smdiff-dcw       -              256,445      1,248,543
```


